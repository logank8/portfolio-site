import{_ as l,c as o,j as e,n as a,a1 as n,a as i,o as r}from"./chunks/framework.D_tc8BW1.js";const d="/assets/particles.CcQRUYpw.mp4",m="/assets/game_lighting.DsIBTTFV.png",h="/assets/death.DGoofWyN.mp4",p="/assets/light_flicker.D5tWHHSU.mp4",g="/assets/boids.DmVYQTCz.mp4",c="/assets/elevator.D06tEKQ_.mp4",u="/assets/statemap.B4ApLIsF.png",y="_header_1c53a_2",f="_highlighthead_1c53a_6",w="_figcaption_1c53a_10",v="_media_1c53a_14",b={header:y,highlighthead:f,figcaption:w,media:v},G=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"eviction-game.md","filePath":"eviction-game.md"}'),k={name:"eviction-game.md"};function $(t,s,S,P,D,B){return r(),o("div",null,[e("h1",{class:a(t.$style.header)},"Eviction of the Damned: 2D Video Game",2),s[5]||(s[5]=n('<h2><h2 id="project-summary" tabindex="-1">Project Summary <a class="header-anchor" href="#project-summary" aria-label="Permalink to &quot;Project Summary&quot;">​</a></h2></h2> I worked with a team of 4 other developers over 4 months to create a 2D dungeon crawler video game in C++ and OpenGL with an ECS structure. We participated in 4 different cross-play user testing sessions throughout development and implemented feedback as needed. In addition to playing a large role in the project management and debugging, I was responsible for the graphics programming, scene management, BOIDS algorithm implementation for the swarm enemy, tilemap implementation, 2d asset uploads and audio. <h2><h2 id="skills-showcased" tabindex="-1">Skills showcased <a class="header-anchor" href="#skills-showcased" aria-label="Permalink to &quot;Skills showcased&quot;">​</a></h2></h2><li>Shaders in OpenGL</li><li>Particle systems</li><li>Render system troubleshooting</li><li>Game scene management</li><li>Project management</li><li>User testing and feedback review</li><h2><h2 id="highlights" tabindex="-1">Highlights <a class="header-anchor" href="#highlights" aria-label="Permalink to &quot;Highlights&quot;">​</a></h2></h2>',10)),e("h4",{class:a(t.$style.highlighthead)},"Particle system",2),s[6]||(s[6]=e("p",null,"I added a smoke effect using a particle system that went created an emitter after an enemy dies.",-1)),e("figure",null,[e("video",{controls:"",loop:"",width:"500",autoplay:"",muted:"",class:a(t.$style.media)},s[0]||(s[0]=[e("source",{src:d,type:"video/mp4"},null,-1)]),2),e("figcaption",{class:a(t.$style.figcaption)},"In-game examples of the smoke particle effect.",2)]),s[7]||(s[7]=e("p",null,[i("To add this into an ECS, I kept each particle as simple structs stored in the ParticleEmitter component of the Smoke entity created. I mainly used "),e("a",{href:"https://www.lri.fr/perso/~mbl/ENS/IG2/devoir2/files/docs/particles.pdf"},"this article"),i(" by Jeff Lander to guide me, especially on adding things like variance and randomness in direction.")],-1)),s[8]||(s[8]=e("p",null,"In Lander's article the pools of particles are implemented using a linked list, which I believe would be possible to implement within our ECS, so I may look into this as a way to reduce unnecessarily redundant storage on large amounts of particles.",-1)),e("h4",{class:a(t.$style.highlighthead)},"Lighting model",2),s[9]||(s[9]=e("p",null,"I implemented a Phong lighting model into the game using OpenGL and created all functions that darkened and lightened the screen through the shader.",-1)),e("figure",null,[e("img",{src:m,width:"500",class:a(t.$style.media)},null,2),e("figcaption",{class:a(t.$style.figcaption)},"Full image of the local illumination model.",2)]),e("figure",null,[e("video",{controls:"",loop:"",width:"350",autoplay:"",muted:"",class:a(t.$style.media)},s[1]||(s[1]=[e("source",{src:h,type:"video/mp4"},null,-1)]),2),e("figcaption",{class:a(t.$style.figcaption)},"When the player dies, the screen slowly darkens and then moves to the Game Over menu screen.",2)]),e("figure",null,[e("video",{controls:"",loop:"",width:"350",autoplay:"",muted:"",class:a(t.$style.media)},s[2]||(s[2]=[e("source",{src:p,type:"video/mp4"},null,-1)]),2),e("figcaption",{class:a(t.$style.figcaption)},"The light flickers randomly throughout the game to add an unsettling energy to the game visuals.",2)]),s[10]||(s[10]=e("p",null,"This included a slow darken when the player dies, as well as a randomly occurring light flicker effect to add ambience.",-1)),e("h4",{class:a(t.$style.highlighthead)},"Boids swarm simulation",2),s[11]||(s[11]=e("p",null,"I used a boids flocking algorithm to create a swarm enemy that chased the player and could be individually killed.",-1)),e("figure",null,[e("video",{controls:"",loop:"",width:"400",autoplay:"",muted:"",class:a(t.$style.media)},s[3]||(s[3]=[e("source",{src:g,type:"video/mp4"},null,-1)]),2),e("figcaption",{class:a(t.$style.figcaption)},"Fighting and being chased by multiple swarms (other components were disabled during this demonstration).",2)]),e("h4",{class:a(t.$style.highlighthead)},"Scene management",2),s[12]||(s[12]=e("p",null,'I handled all transitions between splash screens, menus, cutscenes, and gameplay. I also designed the main menu "elevator" display, which allows the player to access any levels that they have "unlocked" by playing previously.',-1)),e("figure",null,[e("video",{controls:"",loop:"",width:"400",autoplay:"",muted:"",class:a(t.$style.media)},s[4]||(s[4]=[e("source",{src:c,type:"video/mp4"},null,-1)]),2),e("figcaption",{class:a(t.$style.figcaption)},"Elevator main menu when only the first level is unlocked.",2)]),e("figure",null,[e("img",{src:u,width:"400",class:a(t.$style.media)},null,2),e("figcaption",{class:a(t.$style.figcaption)},"My layout of the state transitions for the game.",2)]),e("h4",{class:a(t.$style.highlighthead)},"2D Physics system",2),s[13]||(s[13]=e("p",null,"The physics system was a collaborative effort across the entire team. However, I am most proud of my work on the AABB collisions and radius-based proximity detection for interactable objects such as health buffs, NPCs, and doors.",-1))])}const I={$style:b},j=l(k,[["render",$],["__cssModules",I]]);export{G as __pageData,j as default};
